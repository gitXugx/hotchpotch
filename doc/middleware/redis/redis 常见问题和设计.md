# Redis 常见问题

## redis key的设计
type:ID:属性 value ,key和value应该尽量小

## redis 分布式锁

如果使用redis做分布式锁，理论上来说是可以符合一些业务场景，在之前的文章中说过redis的sentinel模式和culster模式都会带来一些数据丢失问题，那么如果在数据丢失情况下会导致重复获取锁的问题。

**丢失锁主要场景**

单机可以实现分布式锁，但是单机没有高可用。

集群或者主从具有锁重复获取的问题:

1. 主节点处理用户1请求成功，获取到锁，异步同步从节点和持久化时候发生宕机，这时用户2像新的主节点申请锁成功
2. culster 场景也会出现同样的问题。
3. 出现网络分区的时候也会导致锁重复获取

redis 官方给出的方案时 `redlock` 方式 :
1. 通过部署多台无从节点的 `master` 
2. 客户端获取需要向master集群获取锁，在锁过期时间内，获取到的锁数量> master/2+1 即为获取成功
3. 执行完后释放所获得的锁
4. 存活的集群节点要大于3，否则出现宕机，会导致应用无法获取锁
5. 出现网络分区时，可能会获取多个锁
6. 如果一台机器获取到锁，拥有一般机器+1的锁，但是其中一台宕机重启，其他用户来获取，也可能获取到另一半+重启的这台机器的锁，可以通过重启保护，但是如果大部分集群宕机重启，将导致一段时间不可用

这种方式虽然这种方案要比之前的sentinel和culster要稍微安全，但是这种集群只能做分布式锁，成本有点高

## redis 持久化选择

**持久化对主线程的影响:**

如果在数据比较重要的情况下，可能需要保证 AOF和RDB 都需要开启 ，但是RDB创建 和AOF重写 执行bgsave和bgrewriteaof来进行fork一个线程，进行处理，因为是主线程来进行fork所以会阻塞主线程。在bgsave时只少要保留和当前实例一般的空闲内存来执行，否则可能照成swap和内存空间溢出的问题。bgrewriteaof 有两种写方式，一种时缓存写，先把数据存在AOFrewrite缓存中，然后执行操作系统的write函数，进行刷新到磁盘，还有一种时fsync同步模式，只要有数据就进行刷到磁盘中，这样对磁盘消耗比较大。如果主线程写比较多的情况下，AOF在追加写入的时候，fsync返回又比较慢的情况会导致主线程等待fork线程，因为主线程持续添加 aof_rewrite_buf 会导致磁盘负载很高，可能导致redis进行异常退出，可能损失的数据更多，主线程等待fork线程只是一种保护策略

**AOF重写，在合适的条件下可以在系统请求较少的时候进行重写，可以在对应的服务器上进行定时任务手动执行bgrewrite命令**


**数据完完整性对**

1. 如果对数据的完整性要求不高, 可以master不进行RDB和AOF，备机进行RDB或者AOF进行备份，以保证master性能最佳，但是master的自动重启和不备份不能同时设置，因为在master瞬间重启，数据丢失那么备机数据也将全部丢失
2. 如果对数据要求高，那么需要对master节点进行AOF备份，如果写命令比较多的情况下，设置追加写入可以是 exeync或者是always，如果对磁盘资源抗的住的话可以使用 always, 从节点也要进行对应的备份。

## 常见问题

**redis 大量key插入**

官方有提供的pipe mode来进行插入

**redis 事务问题**
redis事务并不像mysql那样会回滚，redis事务是通过multi，exec 来进行执行，错误命令会报错，但是成功的命令会执行，因为redis认为命令错误的情况只有你命令写错，回滚只有一种情况，就是客户端在事务期间断开连接

watch命令事redis基于cas实现的乐观锁，因为在操作事务时，可能由于其他线程修改key值而导致当前客户进行覆盖而使用的命令

watch使用地方还是很多的，例如存储库存，使用watch对库存进行一个监听，然后来进行减库存，以防超卖的情况。


## 内存突然增大

1. 客户端执行高危命令 moniter fushdb等导致内存增高
2. key分配不均匀一般不会出现这种问题
有可能客户端处理不过来服务端返回的数据，导致再客户缓存区堆积导致内存增大
可以通过查看客户端连接来找到对应出问题的命令，如果情况紧急可以故障转移

## 缓存问题

只讨论后端数据库缓存问题

**缓存穿透**

可能网站被攻击或者大量请求查询不存在的key，请求直接打到数据库，因为很多时候是在数据库中读取到值才进行缓存到数据库，读取不到直接返回null


<div align="center"> <img src="缓存穿透" /> </div><br>

解决方式，通常把 `key - null`  放入到缓存, 设置尽量小的过期时间。


**缓存一致性问题**

1. 使用分布式事务



2. 并发更新问题



















