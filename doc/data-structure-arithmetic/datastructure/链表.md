# 链表
> 链表和数组一样属于线性数据结构, 与数组不一样的是内存是不需要连续的。

- [x] 什么是链表
- [x] 链表和数组比较
- [ ] 链表的使用



## 什么是链表
> 链表是一种物理存储单元上可以是非连续、非顺序的存储结构, 数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。

一般链表的实现有一下几种:
* 单向链表
* 循环链表
* 双向链表

### 单向链表
下面是一个简单的链表
<div align="center"> <img src="../images/链表内存图.jpg" /> </div><br>

上面链表和数组的不同
1. 每个节点数据分散在不连续内存中的不同位置
2. 有一个链表头 (链表的第一个元素), 链表尾不会再有其他的节点。
3. 每一个节点都会有下一个节点的指针 (当在内存要求高的情况下, 变向的浪费内存)


**查找和访问：**

1. 单向列表支持查找, 但是不支持随机访问, 因为内存空间是不连续的, 在只能从链表头开访问。
2. 单向链表的查找, 时间复杂度属于 `O(n)` 只能从前往后进行一个遍历


**删除和插入:**

1. 删除只需要把前一个节点的指针(next)指向被删除节点的下一个指针即可, 类似 `pre -> current -> next`  到 `pre -> next`, 时间复杂度属于 `O(1)`, 但是查找前一个节点依然要遍历 `O(n)`

<div align="center"> <img src="../images/链表删除元素.jpg" /> </div><br>

2. 插入只需要修改要插入节点的前一个节点指向插入的元素, 插入的元素指向插入点的元素, 类似 `pre -> now -> next` 到 `pre -> new -> now -> next` , 但是查找前一个节点依然要遍历 `O(n)`

<div align="center"> <img src="../images/链表插入元素.jpg" /> </div><br>

**代码:**


## 循环链表
> 尾部的 `next` 指向头节点, 使头尾相连形成一个循环链表, 而不是链表尾部指向 `null`

<div align="center"> <img src="../images/循环链表.jpg" /> </div><br>


## 双向链表
双向链表解决的就是单向链表删除或者插入时需要遍历的问题, 导致效率低的问题。用的空间换时间的方式, 再单向链表原有的基础上再添加一个指向前一个节点的指针。这样在使用删除和添加的时候就不用区遍历找到前一个节点而消耗性能。

<div align="center"> <img src="../images/双向链表.jpg" /> </div><br>


**代码:**


## 链表和数组比较
链表的插入、删除、查询、不支持随机访问, 数组的插入、删除、查询、支持随机访问。

|结构|插入|删除|查询|随机访问|
|:--:|:--:|:--:|:---:|:----:|
|无序数组|O(n)|O(n)|O(n)|O(1)|
|有序数组|O(n)|O(n)|O(logn)|O(1)|
|单向链表|O(1)|O(1)|O(n)|不支持|
|双向链表|O(1)|O(1)|O(n)|不支持|

- 链表解决了数组分配内存是连续空间的问题, 但是也相对增加了内存碎片, 导致GC频繁回收的问题。
- 数组扩容在大量数据的情况下, 这段时间占用大量内存和数据复制消耗性能是不可避免的, 而链表可以在内存有的情况下可以随意添加节点。
- 当存储同等数据下, 链表使用的内存更多, 因为它不仅有数据而且有指向其下一个节点的指针。
- 链表因为内存是不连续的, 对CPU缓存的支持比较差, 而数组是连续的数据空间, 能够很好的利用CPU缓存, 来使数据的访问更快。
  
## 链表的使用

* 单链反转
* 链表中环检测
* 俩有序链表合并
* 删除链表倒数第n个节点
* 求链表中间节点
* 内存池数据结构

### 链表缓存









